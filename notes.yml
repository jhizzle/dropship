dropship:
  message: a set of K + M packets
  each_packet:
    ChanId: message channel
    GlblSeq: the Sequence of this packet
    MsgSeq: the Sequence number of this packet for this message
    K: the number of data pieces
    M: the number of parity pieces
    PktSize: the size of the data in the packet (really, it should be the remaining data)
    MsgSize: the actual amount of data that is valid in this message


receiver
{
receive packet
decode header
check hash
channel exists? if not, create a new channel
send packet to channel
}

channel
{
  accepts packets
  times out after a while if not received a packet
  waits for enough packets to reassemble a message
  outputs data over channel when the message can be decoded
  times out waiting for data if not enough packets have been received to decode message.
    writes null data to allow rest of channel to continue and sends a note to the error channel
}

reassemble
{
}


API:
  NewSession(k, m, datasize, dest)


There is an idea of a channel or session. all data sent on a specific channel
will end up on the same channel at the end. This means that you could
technically interleave packets from different channels.

Data is sent as a "message" where a message is made up of packets.  Each packet
contains information about the message. For example, how many data packets and
parity packets are associated with the message. Each packet also indicates how
to reassemble them into a message. Also, each packet contains information on
which channel the message belongs to.


